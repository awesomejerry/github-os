<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GitHub OS - Terminal</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0d1117;
      color: #c9d1d9;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.6;
      height: 100vh;
      overflow: hidden;
    }

    #terminal {
      height: 100vh;
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    #output {
      flex: 1;
      margin-bottom: 10px;
    }

    .line {
      white-space: pre-wrap;
      word-wrap: break-word;
      margin-bottom: 4px;
    }

    .prompt {
      color: #58a6ff;
    }

    .command {
      color: #c9d1d9;
    }

    .error {
      color: #f85149;
    }

    .success {
      color: #3fb950;
    }

    .info {
      color: #8b949e;
    }

    .directory {
      color: #58a6ff;
    }

    .file {
      color: #c9d1d9;
    }

    .symlink {
      color: #8b949e;
    }

    #input-line {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #input-prompt {
      color: #58a6ff;
      white-space: nowrap;
    }

    #command-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #c9d1d9;
      font-family: inherit;
      font-size: inherit;
      outline: none;
      caret-color: #c9d1d9;
    }

    pre {
      margin: 8px 0;
      padding: 12px;
      background: #161b22;
      border-radius: 6px;
      overflow-x: auto;
    }

    pre code {
      font-family: inherit;
      font-size: 13px;
    }

    .welcome {
      color: #58a6ff;
      font-weight: bold;
    }

    .emoji {
      font-style: normal;
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="output"></div>
    <div id="input-line">
      <span id="input-prompt">guest@github-os:~$</span>
      <input type="text" id="command-input" autofocus autocomplete="off" spellcheck="false">
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    // Configuration - Auto-detect from GitHub Pages URL, fallback to this user
    const DEFAULT_GITHUB_USER = 'awesomejerryshen';
    
    // Auto-detect GitHub username from GitHub Pages URL
    function detectGitHubUser() {
      const hostname = window.location.hostname;
      // Match *.github.io pattern
      const match = hostname.match(/^([^.]+)\.github\.io$/);
      if (match) {
        return match[1];
      }
      return DEFAULT_GITHUB_USER;
    }
    
    // State
    let currentPath = '/';
    let githubUser = detectGitHubUser();
    let repoCache = {};
    let commandHistory = [];
    let historyIndex = -1;

    // DOM elements
    const output = document.getElementById('output');
    const input = document.getElementById('command-input');
    const promptEl = document.getElementById('input-prompt');

    // Initialize
    async function init() {
      printWelcome();
      updatePrompt();
      
      // Load repos on start
      await loadRepos();
    }

    function printWelcome() {
      const welcomeText = `
<span class="welcome">Welcome to GitHub OS v1.0.0</span>
Connecting to GitHub user: <span class="success">${githubUser}</span>

Type <span class="info">'help'</span> for available commands.

`;
      print(welcomeText);
    }

    function print(text, className = '') {
      const line = document.createElement('div');
      line.className = 'line ' + className;
      line.innerHTML = text;
      output.appendChild(line);
      scrollToBottom();
    }

    function scrollToBottom() {
      const terminal = document.getElementById('terminal');
      terminal.scrollTop = terminal.scrollHeight;
    }

    function updatePrompt() {
      const pathDisplay = currentPath === '/' ? '~' : `~${currentPath}`;
      promptEl.textContent = `guest@github-os:${pathDisplay}$`;
    }

    // GitHub API functions
    async function loadRepos() {
      try {
        print(`<span class="info">Loading repositories...</span>`);
        const response = await fetch(`https://api.github.com/users/${githubUser}/repos?per_page=100&sort=updated`);
        if (!response.ok) throw new Error('User not found');
        const repos = await response.json();
        
        repoCache['/'] = repos.map(repo => ({
          name: repo.name,
          type: 'dir',
          description: repo.description,
          stars: repo.stargazers_count,
          forks: repo.forks_count,
          language: repo.language
        }));
        
        print(`<span class="success">Loaded ${repos.length} repositories</span>\n`);
      } catch (error) {
        print(`<span class="error">Error: ${error.message}</span>\n`);
      }
    }

    async function loadRepoContents(owner, repo, path = '') {
      const cacheKey = `/${owner}/${repo}/${path}`;
      if (repoCache[cacheKey]) {
        return repoCache[cacheKey];
      }

      try {
        const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`);
        if (!response.ok) throw new Error('Path not found');
        const contents = await response.json();
        
        const items = Array.isArray(contents) ? contents.map(item => ({
          name: item.name,
          type: item.type === 'dir' ? 'dir' : 'file',
          size: item.size,
          download_url: item.download_url
        })) : contents;

        repoCache[cacheKey] = items;
        return items;
      } catch (error) {
        throw error;
      }
    }

    async function loadFileContent(owner, repo, path) {
      try {
        const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`);
        if (!response.ok) throw new Error('File not found');
        const file = await response.json();
        
        if (file.type !== 'file') throw new Error('Not a file');
        
        const content = atob(file.content);
        return { content, name: file.name };
      } catch (error) {
        throw error;
      }
    }

    // Path utilities
    function parsePath(path) {
      // Remove leading/trailing slashes and split
      const parts = path.replace(/^\/|\/$/g, '').split('/').filter(p => p);
      
      if (parts.length === 0) {
        return { owner: null, repo: null, path: '' };
      } else if (parts.length === 1) {
        return { owner: githubUser, repo: parts[0], path: '' };
      } else {
        return { owner: githubUser, repo: parts[1], path: parts.slice(2).join('/') };
      }
    }

    function resolvePath(path) {
      if (path.startsWith('/')) {
        return path;
      }
      
      const current = currentPath === '/' ? '' : currentPath;
      let resolved = (current + '/' + path).replace(/\/+/g, '/');
      
      // Handle . and ..
      const parts = resolved.split('/').filter(p => p);
      const result = [];
      
      for (const part of parts) {
        if (part === '.') continue;
        if (part === '..') {
          result.pop();
        } else {
          result.push(part);
        }
      }
      
      return '/' + result.join('/');
    }

    // Commands
    async function executeCommand(cmdLine) {
      const parts = cmdLine.trim().split(/\s+/);
      const cmd = parts[0].toLowerCase();
      const args = parts.slice(1);

      print(`<span class="prompt">${promptEl.textContent}</span> <span class="command">${cmdLine}</span>`);

      switch (cmd) {
        case 'help':
          cmdHelp();
          break;
        case 'ls':
          await cmdLs(args);
          break;
        case 'cd':
          await cmdCd(args);
          break;
        case 'pwd':
          cmdPwd();
          break;
        case 'cat':
          await cmdCat(args);
          break;
        case 'tree':
          await cmdTree(args);
          break;
        case 'clear':
          cmdClear();
          break;
        case 'exit':
          print(`<span class="info">Goodbye!</span>`);
          break;
        default:
          print(`<span class="error">Command not found: ${cmd}. Type 'help' for available commands.</span>`);
      }
      
      print(''); // Add spacing
    }

    function cmdHelp() {
      const help = `
<span class="success">Available Commands:</span>

  <span class="info">ls</span> [path]        List directory contents
  <span class="info">cd</span> &lt;path&gt;        Change directory
  <span class="info">pwd</span>               Print working directory
  <span class="info">cat</span> &lt;file&gt;        Display file contents
  <span class="info">tree</span> [path]       Display directory tree
  <span class="info">clear</span>             Clear terminal screen
  <span class="info">help</span>              Show this help message
  <span class="info">exit</span>              Exit terminal

<span class="info">Tips:</span>
  - Use <span class="success">cd ..</span> to go up one directory
  - Use <span class="success">cd /</span> to go to root (repository list)
  - Press <span class="success">↑/↓</span> to navigate command history
`;
      print(help);
    }

    async function cmdLs(args) {
      const targetPath = args[0] ? resolvePath(args[0]) : currentPath;
      const parsed = parsePath(targetPath);

      try {
        if (targetPath === '/') {
          // List repositories
          const repos = repoCache['/'];
          if (!repos) {
            print(`<span class="error">Repositories not loaded. Please wait...</span>`);
            return;
          }
          
          print('');
          repos.forEach(repo => {
            const lang = repo.language ? ` [<span class="info">${repo.language}</span>]` : '';
            const stars = repo.stars > 0 ? ` <span class="success">★${repo.stars}</span>` : '';
            print(`<span class="directory">${repo.name}/</span>${lang}${stars}`);
            if (repo.description) {
              print(`  <span class="info">${repo.description}</span>`);
            }
          });
          print(`\n<span class="info">${repos.length} repositories</span>`);
        } else {
          // List repo contents
          const contents = await loadRepoContents(parsed.owner, parsed.repo, parsed.path);
          
          if (!Array.isArray(contents)) {
            print(`<span class="error">Not a directory</span>`);
            return;
          }
          
          print('');
          contents.forEach(item => {
            if (item.type === 'dir') {
              print(`<span class="directory">${item.name}/</span>`);
            } else {
              const size = item.size ? ` <span class="info">(${formatBytes(item.size)})</span>` : '';
              print(`<span class="file">${item.name}</span>${size}`);
            }
          });
          print(`\n<span class="info">${contents.length} items</span>`);
        }
      } catch (error) {
        print(`<span class="error">Error: ${error.message}</span>`);
      }
    }

    async function cmdCd(args) {
      if (args.length === 0) {
        print(`<span class="error">Usage: cd &lt;directory&gt;</span>`);
        return;
      }

      const targetPath = resolvePath(args[0]);
      const parsed = parsePath(targetPath);

      try {
        if (targetPath === '/') {
          currentPath = '/';
          updatePrompt();
          return;
        }

        // Validate the path exists
        if (parsed.path === '') {
          // Navigating to a repo, check if it exists
          const repos = repoCache['/'];
          if (!repos.find(r => r.name === parsed.repo)) {
            print(`<span class="error">Repository not found: ${parsed.repo}</span>`);
            return;
          }
        } else {
          // Check if directory exists
          const contents = await loadRepoContents(parsed.owner, parsed.repo, parsed.path);
          // If we got here without error, the path is valid
        }

        currentPath = targetPath;
        updatePrompt();
      } catch (error) {
        print(`<span class="error">Error: ${error.message}</span>`);
      }
    }

    function cmdPwd() {
      print(currentPath === '/' ? '/' : currentPath);
    }

    async function cmdCat(args) {
      if (args.length === 0) {
        print(`<span class="error">Usage: cat &lt;file&gt;</span>`);
        return;
      }

      const targetPath = resolvePath(args[0]);
      const parsed = parsePath(targetPath);

      if (targetPath === '/' || parsed.path === '') {
        print(`<span class="error">Not a file</span>`);
        return;
      }

      try {
        const { content, name } = await loadFileContent(parsed.owner, parsed.repo, parsed.path);
        
        // Detect language for syntax highlighting
        const ext = name.split('.').pop().toLowerCase();
        const langMap = {
          'js': 'javascript',
          'jsx': 'javascript',
          'ts': 'typescript',
          'tsx': 'typescript',
          'py': 'python',
          'rb': 'ruby',
          'java': 'java',
          'c': 'c',
          'cpp': 'cpp',
          'cs': 'csharp',
          'go': 'go',
          'rs': 'rust',
          'php': 'php',
          'swift': 'swift',
          'kt': 'kotlin',
          'scala': 'scala',
          'sh': 'bash',
          'bash': 'bash',
          'zsh': 'bash',
          'json': 'json',
          'xml': 'xml',
          'html': 'html',
          'css': 'css',
          'scss': 'scss',
          'less': 'less',
          'md': 'markdown',
          'yml': 'yaml',
          'yaml': 'yaml',
          'sql': 'sql',
          'vue': 'vue',
          'svelte': 'svelte'
        };

        const lang = langMap[ext] || 'plaintext';
        
        print(`<pre><code class="language-${lang}">${escapeHtml(content)}</code></pre>`);
        
        // Apply syntax highlighting
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      } catch (error) {
        print(`<span class="error">Error: ${error.message}</span>`);
      }
    }

    async function cmdTree(args) {
      const targetPath = args[0] ? resolvePath(args[0]) : currentPath;
      const parsed = parsePath(targetPath);

      if (targetPath === '/') {
        print(`<span class="info">Repository listing (use 'ls' to see details):</span>\n`);
        const repos = repoCache['/'];
        if (!repos) {
          print(`<span class="error">Repositories not loaded</span>`);
          return;
        }
        repos.forEach(repo => {
          print(`<span class="directory">${repo.name}/</span>`);
        });
        return;
      }

      print(`<span class="info">Loading directory tree...</span>`);
      await printTree(parsed.owner, parsed.repo, parsed.path, '', true);
    }

    async function printTree(owner, repo, path, prefix = '', isLast = true, depth = 0) {
      if (depth > 3) {
        print(`${prefix}<span class="info">...</span>`);
        return;
      }

      try {
        const contents = await loadRepoContents(owner, repo, path);
        
        if (!Array.isArray(contents)) return;

        for (let i = 0; i < contents.length; i++) {
          const item = contents[i];
          const isLastItem = i === contents.length - 1;
          const connector = isLastItem ? '└── ' : '├── ';
          const newPrefix = prefix + (isLastItem ? '    ' : '│   ');

          if (item.type === 'dir') {
            print(`${prefix}${connector}<span class="directory">${item.name}/</span>`);
            await printTree(owner, repo, path ? `${path}/${item.name}` : item.name, newPrefix, isLastItem, depth + 1);
          } else {
            print(`${prefix}${connector}<span class="file">${item.name}</span>`);
          }
        }
      } catch (error) {
        print(`${prefix}<span class="error">Error loading: ${error.message}</span>`);
      }
    }

    function cmdClear() {
      output.innerHTML = '';
    }

    // Utilities
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Event listeners
    input.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        const cmdLine = input.value;
        input.value = '';
        
        if (cmdLine.trim()) {
          commandHistory.push(cmdLine);
          historyIndex = commandHistory.length;
          await executeCommand(cmdLine);
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.value = commandHistory[historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.value = commandHistory[historyIndex];
        } else {
          historyIndex = commandHistory.length;
          input.value = '';
        }
      } else if (e.key === 'Tab') {
        e.preventDefault();
        // Tab completion could be added here
      }
    });

    // Focus input on click
    document.getElementById('terminal').addEventListener('click', () => {
      input.focus();
    });

    // Initialize on load
    init();
  </script>
</body>
</html>
